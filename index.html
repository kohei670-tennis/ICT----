<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>等加速度運動（ストロボ＋位置ラベル＋表示範囲）</title>
  <style>
    :root{
      --bg:#0b1220;
      --card: rgba(255,255,255,.06);
      --border: rgba(255,255,255,.10);
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --good:#34d399;
      --warn:#fbbf24;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
      background: radial-gradient(1200px 600px at 12% 8%, #142a5a 0%, var(--bg) 50%, #070b14 100%);
    }
    header{
      padding:16px 16px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    header h1{ margin:0; font-size:18px; letter-spacing:.02em; }
    header .sub{ margin-top:6px; color:var(--muted); font-size:12px; line-height:1.5; }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:12px;
      display:grid;
      grid-template-columns: 1.25fr 0.9fr;
      gap:12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns:1fr; }
    }

    .card{
      background: linear-gradient(180deg, var(--card), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      box-shadow: 0 18px 55px rgba(0,0,0,.35);
      min-width:0;
    }
    .card h2{
      margin:0;
      padding:10px 12px;
      font-size:14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.15);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .content{ padding:12px; }

    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pill{
      font-size:12px;
      padding:6px 10px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      background: rgba(0,0,0,.18);
      color: var(--muted);
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      user-select:none;
    }
    .btn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.14);
      color:var(--text);
      background: rgba(0,0,0,.18);
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
      transition:.15s;
    }
    .btn:hover{ border-color: rgba(255,255,255,.28); transform: translateY(-1px); }
    .btn.primary{ background: rgba(96,165,250,.18); border-color: rgba(96,165,250,.40); }
    .btn.good{ background: rgba(52,211,153,.14); border-color: rgba(52,211,153,.35); }
    .btn.warn{ background: rgba(251,191,36,.10); border-color: rgba(251,191,36,.35); }

    /* Main simulation canvas: BIG */
    #sim{
      width:100%;
      height:520px; /* ←大きく表示 */
      display:block;
      background: rgba(0,0,0,.10);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
    }
    @media (max-width: 600px){
      #sim{ height:420px; }
    }

    .kv{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .kv .box{
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      min-width:0;
    }
    .kv .k{ font-size:12px; color:var(--muted); }
    .kv .v{ margin-top:4px; font-size:18px; font-variant-numeric: tabular-nums; }

    .panel{
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
    }
    .panel + .panel{ margin-top:10px; }

    .label{ font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type="range"]{ width:100%; }
    .val{ margin-left:auto; color:#dbeafe; font-size:13px; font-variant-numeric: tabular-nums; }

    .hint{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      color:var(--muted);
      font-size:12px;
      line-height:1.55;
    }
    .hint b{ color:#dbeafe; }

    footer{
      max-width:1200px;
      margin:0 auto;
      padding:0 12px 16px;
      color:var(--muted);
      font-size:12px;
      line-height:1.55;
    }
  </style>
</head>

<body>
<header>
  <h1>等加速度運動（1次元）— ストロボ＋位置ラベル＋表示範囲</h1>
  <div class="sub">
    仕様：<b>x0=0固定</b>（初期位置スライダーなし）。ストロボONでΔtごとに残像点＋<b>x軸上に位置値</b>を表示。<br>
    表示範囲（±Xmax）を変えると、物体が画面外へ行っても追えます。
  </div>
</header>

<div class="wrap">
  <!-- LEFT: Simulation -->
  <section class="card">
    <h2>
      <span>シミュレーション（大きめ表示）</span>
      <span class="row">
        <span class="pill" id="pillInfo">x0=0 固定</span>
        <button class="btn primary" id="btnPlay">再生</button>
        <button class="btn" id="btnPause">停止</button>
        <button class="btn warn" id="btnReset">リセット</button>
        <button class="btn" id="btnFullscreen">全画面</button>
      </span>
    </h2>
    <div class="content">
      <canvas id="sim"></canvas>

      <div class="kv">
        <div class="box"><div class="k">時刻 t [s]</div><div class="v" id="readT">0.00</div></div>
        <div class="box"><div class="k">位置 x [m]</div><div class="v" id="readX">0.00</div></div>
        <div class="box"><div class="k">速度 v [m/s]</div><div class="v" id="readV">0.00</div></div>
        <div class="box"><div class="k">加速度 a [m/s²]</div><div class="v" id="readA">0.00</div></div>
      </div>

      <div class="hint">
        <b>見どころ</b>：ストロボ点の間隔が時間とともに変わります（加速なら広がる、減速なら詰まる）。<br>
        速度0の瞬間があっても、加速度が0とは限りません。
      </div>
    </div>
  </section>

  <!-- RIGHT: Controls -->
  <section class="card">
    <h2>
      <span>操作</span>
      <span class="row">
        <button class="btn" id="btnStrobeToggle">ストロボ OFF</button>
        <button class="btn warn" id="btnStrobeClear">残像クリア</button>
      </span>
    </h2>

    <div class="content">
      <div class="panel">
        <div class="row">
          <div class="label">初速度 v0 [m/s]</div>
          <div class="val" id="valV0"></div>
        </div>
        <input id="v0" type="range" min="-10" max="10" step="0.1" value="2" />

        <div style="height:10px;"></div>

        <div class="row">
          <div class="label">加速度 a [m/s²]</div>
          <div class="val" id="valA"></div>
        </div>
        <input id="a" type="range" min="-10" max="10" step="0.1" value="1" />

        <div style="height:10px;"></div>

        <div class="row">
          <div class="label">表示時刻 t [s]（停止中に調整）</div>
          <div class="val" id="valT"></div>
        </div>
        <input id="t" type="range" min="0" max="10" step="0.01" value="0" />
      </div>

      <div class="panel">
        <div class="row">
          <div class="label">x軸表示範囲（±Xmax）[m]</div>
          <div class="val" id="valXMax"></div>
        </div>
        <input id="xMax" type="range" min="5" max="120" step="1" value="25" />

        <div class="hint" style="margin-top:10px;">
          物体が端に寄って見にくいときは、±Xmaxを広げてください。
        </div>
      </div>

      <div class="panel">
        <div class="row">
          <div class="label">ストロボ間隔 Δt [s]</div>
          <div class="val" id="valStrobeDt"></div>
        </div>
        <input id="strobeDt" type="range" min="0.02" max="0.50" step="0.01" value="0.10" />

        <div class="hint" style="margin-top:10px;">
          Δtを小さくすると残像が密になり、ラベルは自動的に間引き表示します（重なり防止）。
        </div>
      </div>
    </div>
  </section>
</div>

<footer>
  実装：Canvasのみ（HTML/JS単体）。ストロボはΔtごとに位置を記録し、レール上に点＋「x=…m」ラベルを描画します。
</footer>

<script>
(() => {
  // =========================
  //  基本ユーティリティ
  // =========================
  const $ = (id) => document.getElementById(id);
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const fmt = (n, d=2) => (Number.isFinite(n) ? n.toFixed(d) : "—");

  function setupCanvas(c){
    const dpr = window.devicePixelRatio || 1;
    const rect = c.getBoundingClientRect();
    c.width = Math.floor(rect.width * dpr);
    c.height = Math.floor(rect.height * dpr);
    const ctx = c.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
    return ctx;
  }

  function roundRectPath(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  // =========================
  //  状態（x0=0固定）
  // =========================
  const X0 = 0;
  const st = {
    v0: 2,
    a: 1,
    t: 0,
    simT: 0,
    playing: false,

    // view range
    xMax: 25,

    // strobe
    strobeOn: false,
    strobeDt: 0.10,
    strobePoints: [], // {t, x}
    nextStrobeT: 0,

    lastTs: performance.now(),
  };

  // =========================
  //  物理
  // =========================
  const vAt = (t) => st.v0 + st.a * t;
  const xAt = (t) => X0 + st.v0 * t + 0.5 * st.a * t * t;

  // =========================
  //  ストロボ
  // =========================
  function resetStrobe(){
    st.strobePoints = [];
    st.nextStrobeT = st.simT; // 現在時刻からサンプリング
  }

  function sampleStrobeBetween(prevT, currT){
    if(!st.strobeOn) return;
    const dt = Math.max(0.001, st.strobeDt);

    // nextStrobeT が過去に取り残されるのを防ぐ
    if(st.nextStrobeT < prevT) st.nextStrobeT = prevT;

    while(st.nextStrobeT <= currT + 1e-9){
      const t = st.nextStrobeT;
      st.strobePoints.push({ t, x: xAt(t) });
      if(st.strobePoints.length > 1400) st.strobePoints.shift(); // メモリ上限
      st.nextStrobeT += dt;
    }
  }

  // =========================
  //  描画（大きめ）
  // =========================
  function drawSim(){
    const c = $("sim");
    const ctx = setupCanvas(c);
    const w = c.getBoundingClientRect().width;
    const h = c.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    // レール位置：下側にラベル帯を確保
    const trackY = h * 0.48;
    const pad = 26;

    // x表示範囲
    const xMin = -st.xMax;
    const xMax =  st.xMax;
    const X = (x)=> pad + (x - xMin) / (xMax - xMin) * (w - 2*pad);

    // 背景グリッド
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.lineWidth = 1;
    for(let i=0;i<=10;i++){
      const gx = pad + i*(w-2*pad)/10;
      ctx.beginPath();
      ctx.moveTo(gx, pad);
      ctx.lineTo(gx, h-pad);
      ctx.stroke();
    }
    ctx.restore();

    // レール
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.28)";
    ctx.lineWidth = 2.2;
    ctx.beginPath();
    ctx.moveTo(pad, trackY);
    ctx.lineTo(w-pad, trackY);
    ctx.stroke();
    ctx.restore();

    // 範囲表示
    ctx.save();
    ctx.fillStyle = "rgba(229,231,235,.78)";
    ctx.font = "13px system-ui, sans-serif";
    ctx.fillText(`x 範囲: ${xMin} ～ ${xMax} [m]`, pad, pad + 12);
    ctx.restore();

    // ストロボ点＋位置ラベル
    if(st.strobeOn && st.strobePoints.length){
      const inView = st.strobePoints.filter(p => p.x >= xMin && p.x <= xMax);
      const src = inView.slice(-260); // 画面負荷軽減

      // 点
      ctx.save();
      for(let i=0;i<src.length;i++){
        const p = src[i];
        const px = X(p.x);
        const age = (src.length - 1 - i);
        const alpha = clamp(0.38 - age*0.0011, 0.05, 0.38);
        ctx.fillStyle = `rgba(96,165,250,${alpha})`;
        ctx.beginPath();
        ctx.arc(px, trackY, 3.6, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // ラベル（重なり防止で間引く）
      const MAX_LABELS = 28;
      const MIN_PX_GAP = 52; // 大きめキャンバス想定
      const range = (xMax - xMin);
      const decimals = range >= 80 ? 0 : (range >= 30 ? 1 : 2);

      ctx.save();
      ctx.font = "15px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";

      let lastLabelPx = -1e9;
      let count = 0;

      // 新しい点を優先して表示（右端に最新が残りやすい）
      for(let i=src.length-1; i>=0; i--){
        const p = src[i];
        const px = X(p.x);
        if(Math.abs(px - lastLabelPx) < MIN_PX_GAP) continue;

        // 目盛り
        ctx.strokeStyle = "rgba(229,231,235,.42)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(px, trackY + 3);
        ctx.lineTo(px, trackY + 14);
        ctx.stroke();

        // ラベル
        const label = "x=" + p.x.toFixed(decimals) + "m";
        const y = trackY + 52; // 余白大きめ
        const padX = 8, padY = 5;
        const textW = ctx.measureText(label).width;

        ctx.fillStyle = "rgba(0,0,0,.40)";
        roundRectPath(ctx, px - textW/2 - padX, y - 18 - padY, textW + padX*2, 18 + padY*2, 8);
        ctx.fill();

        ctx.fillStyle = "rgba(229,231,235,.95)";
        ctx.fillText(label, px, y - 3);

        lastLabelPx = px;
        count++;
        if(count >= MAX_LABELS) break;
      }
      ctx.restore();
    }

    // 物体
    const t = st.simT;
    const x = xAt(t);
    const px = X(x);

    ctx.save();
    ctx.fillStyle = "rgba(96,165,250,.95)";
    ctx.strokeStyle = "rgba(255,255,255,.40)";
    ctx.lineWidth = 2;
    // 少し大きめのブロック
    const size = 46;
    roundRectPath(ctx, px - size/2, trackY - size/2, size, size, 12);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // 速度ベクトル（上）
    const v = vAt(t);
    const dir = v >= 0 ? 1 : -1;
    const arrowLen = clamp(Math.abs(v) * 12, 0, 170);

    ctx.save();
    ctx.strokeStyle = "rgba(52,211,153,.9)";
    ctx.fillStyle = "rgba(52,211,153,.9)";
    ctx.lineWidth = 4;
    const ay = trackY - 52;
    ctx.beginPath();
    ctx.moveTo(px, ay);
    ctx.lineTo(px + dir*arrowLen, ay);
    ctx.stroke();
    // head
    ctx.beginPath();
    ctx.moveTo(px + dir*arrowLen, ay);
    ctx.lineTo(px + dir*(arrowLen - 14), ay - 10);
    ctx.lineTo(px + dir*(arrowLen - 14), ay + 10);
    ctx.closePath();
    ctx.fill();

    ctx.font = "14px system-ui, sans-serif";
    ctx.fillText("v", px + dir*(arrowLen + 10), ay + 5);
    ctx.restore();

    // 表示値（右下）
    ctx.save();
    ctx.fillStyle = "rgba(251,191,36,.90)";
    ctx.font = "13px system-ui, sans-serif";
    ctx.fillText(`a=${fmt(st.a,2)} m/s²`, w - pad - 110, pad + 12);
    ctx.restore();
  }

  // =========================
  //  UI同期
  // =========================
  function syncUI(){
    $("valV0").textContent = fmt(st.v0,1);
    $("valA").textContent  = fmt(st.a,1);
    $("valT").textContent  = fmt(st.t,2);
    $("valXMax").textContent = "±" + fmt(st.xMax,0) + " m";
    $("valStrobeDt").textContent = fmt(st.strobeDt,2);

    $("v0").value = st.v0;
    $("a").value  = st.a;
    $("t").value  = st.t;
    $("xMax").value = st.xMax;
    $("strobeDt").value = st.strobeDt;

    $("readT").textContent = fmt(st.simT,2);
    $("readX").textContent = fmt(xAt(st.simT),2);
    $("readV").textContent = fmt(vAt(st.simT),2);
    $("readA").textContent = fmt(st.a,2);

    $("btnStrobeToggle").textContent = st.strobeOn ? "ストロボ ON" : "ストロボ OFF";
    $("btnStrobeToggle").className = "btn" + (st.strobeOn ? " good" : "");

    drawSim();
  }

  function onParamChange(){
    if(!st.playing) st.simT = st.t;
    syncUI();
  }

  // =========================
  //  再生ループ
  // =========================
  function tick(){
    const now = performance.now();
    const dt = (now - st.lastTs) / 1000;
    st.lastTs = now;

    if(st.playing){
      const prevT = st.simT;
      st.simT = clamp(st.simT + dt, 0, 10);
      st.t = st.simT;

      sampleStrobeBetween(prevT, st.simT);

      if(st.simT >= 10) st.playing = false;
      syncUI();
    }
    requestAnimationFrame(tick);
  }

  // =========================
  //  イベント
  // =========================
  function bind(){
    $("v0").addEventListener("input", e => { st.v0 = parseFloat(e.target.value); onParamChange(); });
    $("a").addEventListener("input",  e => { st.a  = parseFloat(e.target.value); onParamChange(); });
    $("t").addEventListener("input",  e => { st.t  = parseFloat(e.target.value); onParamChange(); });

    $("xMax").addEventListener("input", e => { st.xMax = parseFloat(e.target.value); syncUI(); });

    $("strobeDt").addEventListener("input", e => {
      st.strobeDt = parseFloat(e.target.value);
      // サンプリング暴発を避けるため現在時刻に合わせる
      st.nextStrobeT = st.simT;
      syncUI();
    });

    $("btnPlay").addEventListener("click", () => {
      st.playing = true;
      st.lastTs = performance.now();
      if(st.strobeOn && st.strobePoints.length === 0){
        st.nextStrobeT = st.simT;
      }
    });

    $("btnPause").addEventListener("click", () => {
      st.playing = false;
      st.t = st.simT;
      syncUI();
    });

    $("btnReset").addEventListener("click", () => {
      st.playing = false;
      st.simT = 0;
      st.t = 0;
      resetStrobe();
      syncUI();
    });

    $("btnStrobeToggle").addEventListener("click", () => {
      st.strobeOn = !st.strobeOn;
      if(st.strobeOn){
        // ONにした瞬間の点を一つ入れる
        st.nextStrobeT = st.simT;
        st.strobePoints.push({ t: st.simT, x: xAt(st.simT) });
      }
      syncUI();
    });

    $("btnStrobeClear").addEventListener("click", () => {
      resetStrobe();
      syncUI();
    });

    $("btnFullscreen").addEventListener("click", async () => {
      try{
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch{
        alert("全画面にできませんでした。");
      }
    });

    window.addEventListener("resize", () => { drawSim(); });
  }

  // =========================
  //  初期化
  // =========================
  resetStrobe();
  bind();
  syncUI();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
